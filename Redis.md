# Redis怎么实现分布式锁？

Redis实现分布式锁主要依赖于其提供的setnx（set if not exist）命令，这个命令可以在指定的key不存在时，为key设置指定的值。如果key已经存在，则setnx不做任何动作。利用这个特性，我们可以将key视为锁，value视为锁的持有者。

以下是一个简单的Redis分布式锁的实现步骤：
1. 获取锁：
使用setnx命令尝试获取锁。具体做法是，将锁的key设置为一个随机值（通常是UUID），并设置过期时间（防止锁持有者崩溃导致锁无法释放）。如果设置成功，则获取到锁；如果设置失败（即key已经存在），则表示锁已被其他客户端持有，此时需要等待或重试。

````
SET lock_key random_value NX PX 30000
```
其中，lock_key是锁的key，random_value是锁的value（通常是UUID），NX表示只有在key不存在时才设置，PX 30000表示锁的过期时间为30秒。
2. 操作共享资源：

获取到锁后，客户端可以安全地操作共享资源。需要注意的是，由于网络延迟或客户端崩溃等原因，锁的持有者可能无法及时释放锁。因此，在设置锁时，我们需要为其设置一个合理的过期时间，以避免死锁。
3. 释放锁：

当客户端完成对共享资源的操作后，需要释放锁。释放锁时，需要确保只释放自己持有的锁，防止误解锁。具体的做法是，使用Lua脚本先判断锁的value是否为自己的随机值，如果是，则删除该锁。

```
if redis.call("get", KEYS[1]) == ARGV[1] then  
    return redis.call("del", KEYS[1])  
else  
    return 0  
end
```
其中，KEYS[1]是锁的key，ARGV[1]是锁的value（即获取锁时设置的随机值）。这个Lua脚本保证了原子性，即判断锁和删除锁的操作是一个不可分割的整体。

这就是Redis实现分布式锁的基本思路。在实际应用中，还需要考虑一些其他因素，如锁的重入性、锁的公平性、锁的粒度等。同时，由于Redis的分布式特性，还需要考虑如何保证锁的正确性和一致性。例如，当Redis集群发生脑裂时，可能会出现多个客户端同时持有同一个锁的情况，这时就需要使用RedLock等算法来确保锁的正确性。

# 如何保证缓存与数据库双写时的数据一致性
> https://xiaolincoding.com/redis/architecture/mysql_redis_consistency.html



# Redis的五种底层数据结构整理



