# 序列化协议json的字段过大 如何优化

当使用JSON作为序列化协议时，如果某个字段的值过大，可能会导致序列化后的数据体积庞大，进而影响网络传输、存储和解析性能。以下是一些优化JSON序列化中字段过大的方法：

1. 压缩JSON数据：
使用如Gzip、Deflate等压缩算法对JSON数据进行压缩，然后再进行传输或存储。
在接收端，再进行解压缩以还原数据。
2. 分块传输：
如果字段过大，可以考虑将其拆分成多个小块，并分批次传输。
接收端再将这些小块重新组合成完整的数据。
3. 使用二进制格式：
考虑使用如Protocol Buffers、MessagePack、Avro等更紧凑的二进制序列化格式代替JSON。
这些格式通常具有更小的体积和更快的解析速度。
4. 数据压缩算法：
对于某些特定类型的数据（如文本、图片等），可以使用专门的数据压缩算法进一步减小其体积。
5. 减少冗余数据：
去除JSON中的冗余字段或重复数据。
使用更紧凑的数据结构或编码方式来表示数据。
6. 懒加载或异步加载：
如果不需要立即处理所有数据，可以考虑实现懒加载或异步加载机制。
初始时只加载部分数据，然后根据需要加载剩余的数据。
7. 使用流式处理：
对于非常大的数据，可以使用流式处理的方式，边读取边处理，而不是一次性加载整个数据到内存中。
8. 数据库优化：
如果字段过大是因为存储了过多的数据，可以考虑优化数据库设计，如使用分表、分区等策略。
9. 只传输变化的数据：
如果字段的变化不频繁，可以考虑只传输变化的部分数据，而不是每次都传输整个字段。
10. 客户端缓存：
对于频繁访问但变化不频繁的大字段，可以考虑在客户端进行缓存，以减少不必要的网络传输。
在选择优化方法时，需要根据具体的应用场景和需求进行权衡。例如，压缩JSON数据可以减少体积，但会增加CPU的开销；使用二进制格式可以提高性能，但可能增加转换的复杂性。因此，在实际应用中，需要根据实际需求和资源限制来选择合适的优化策略。


# proto2和proto3对空字段的优化

Protocol Buffers（简称 Protobuf）是 Google 开发的一种数据序列化协议（类似于 XML、JSON、YAML 等）。它被广泛用于 RPC 通信和数据存储等场景。Protobuf 有两个主要版本：proto2 和 proto3。这两个版本在处理空字段（即未设置或默认值的字段）时有所不同，并且都进行了相应的优化。

Proto2 中的空字段处理
在 proto2 中，如果一个字段未被设置，那么在序列化消息时，这个字段将不会被包含在序列化结果中。这是因为 proto2 默认使用“required”和“optional”字段修饰符，其中“optional”字段在未被设置时不会序列化。这种处理方式有助于减少序列化后数据的大小，因为只包含实际设置了值的字段。

然而，这也带来了一些问题。由于未设置的字段在序列化时不会包含，接收方在反序列化时无法区分一个字段是未被设置还是其值就是默认值。这可能导致一些混淆和错误。

Proto3 中的空字段处理
在 proto3 中，处理空字段的方式有所不同。首先，proto3 移除了“required”和“optional”修饰符，只保留了“repeated”修饰符用于表示字段可以重复。对于非 repeated 字段，如果未被明确设置，那么它将使用其默认值进行序列化。

这种处理方式的好处是简化了字段的使用，减少了在消息定义中的歧义。然而，这也意味着即使一个字段未被设置，它也会在序列化时包含默认值，从而可能增加序列化后数据的大小。

为了优化这种情况，proto3 提供了一种称为“默认值字段”的特性。当一个字段未被设置时，序列化器会检查该字段的默认值是否与其类型的默认值相同。如果相同，则不会将该字段包含在序列化结果中。这种优化有助于减少序列化后数据的大小，同时保持了与 proto2 类似的语义。

总结
proto2 和 proto3 在处理空字段时采取了不同的策略。proto2 通过不序列化未设置的字段来减少数据大小，但可能导致接收方混淆。而 proto3 则使用默认值字段进行优化，既保持了语义的清晰性，又减少了序列化后数据的大小。在选择使用哪个版本时，需要根据具体的应用场景和需求进行权衡。

# 虚拟内存
> https://www.xiaolincoding.com/os/3_memory/vmem.html#%E6%80%BB%E7%BB%93

## 虚拟内存有什么作用？

第一，虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。比如如游戏或图形设计软件，它们需要大量的内存来运行，可以在运行时只加载当前游戏环境附近的程序和代码。
第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。
第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。

