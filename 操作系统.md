# 虚拟内存有什么作用（小米一面）
> https://xiaolincoding.com/os/3_memory/mem_reclaim.html#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84
第一，虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。
第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。
第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。

# malloc如何分配内存（阿里二面）
> https://xiaolincoding.com/os/3_memory/malloc.html#linux-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7a
malloc 申请内存的时候，会有两种方式向操作系统申请堆内存。

方式一：通过 brk() 系统调用从堆分配内存
方式二：通过 mmap() 系统调用在文件映射区域分配内存；
方式一实现的方式很简单，就是通过 brk() 函数将「堆顶」指针向高地址移动，获得新的内存空间。
方式二通过 mmap() 系统调用中「私有匿名映射」的方式，在文件映射区分配一块内存，也就是从文件映射区“偷”了一块内存。

malloc() 源码里默认定义了一个阈值：

如果用户分配的内存小于 128 KB，则通过 brk() 申请内存；
如果用户分配的内存大于 128 KB，则通过 mmap() 申请内存；

# free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？(大华一面)

malloc 返回给用户态的内存起始地址比进程的堆空间起始地址多了 16 字节。
这个多出来的 16 字节就是保存了该内存块的描述信息，比如有该内存块的大小。
这样当执行 free() 函数时，free 会对传入进来的内存地址向左偏移 16 字节，然后从这个 16 字节的分析出当前的内存块的大小，自然就知道要释放多大的内存了。

# 孤儿进程与僵尸进程

一、基本概念

孤儿进程：
定义：一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。
处理：孤儿进程将被init进程（进程号为1）所收养，并由init进程对它们完成状态收集工作。
危害：孤儿进程本身并没有太大的危害，因为init进程会负责清理它们所占用的资源。
僵尸进程：
定义：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。
危害：僵尸进程会一直占用系统资源，如进程号等，如果系统中存在大量的僵尸进程，可能会导致系统资源紧张，甚至无法产生新的进程。
二、产生原因

孤儿进程：父进程因某种原因（如正常完成工作、接收到终止信号等）退出，而它的子进程还在运行。
僵尸进程：子进程先于父进程结束，但父进程没有调用wait或waitpid来回收子进程的资源。
三、解决方法

避免孤儿进程：
方法一：父进程在退出前，确保所有子进程都已经结束或已经被妥善处理。
方法二：如果父进程可能因某种原因提前退出，可以考虑在父进程中设置一个信号处理函数，当接收到终止信号时，先处理子进程再退出。
避免僵尸进程：
方法一：父进程在子进程结束后，立即调用wait或waitpid来回收子进程的资源。
方法二：如果父进程不关心子进程的结束状态，可以忽略SIGCHLD信号，这样当子进程结束时，系统会自动回收其资源。但这种方法可能会丢失子进程的结束状态信息。
方法三：使用信号处理函数来处理SIGCHLD信号，在信号处理函数中调用wait或waitpid来回收子进程的资源。这种方法既可以避免僵尸进程的产生，又可以获取子进程的结束状态信息。
总结来说，孤儿进程和僵尸进程都是操作系统中可能遇到的问题。通过合理的设计和管理，我们可以有效地避免它们的产生，保证系统的正常运行。
